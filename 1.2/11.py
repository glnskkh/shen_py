# Необходимо поменять a[0..k], a[k+1] местами
# Или, что то же самое, необходимо сдвинуть массив вправо циклически на k элементов
# Вариант 1: перевернуть начало, конец, потом весь
# Вариант 2: расположим элементы по кругу, переставляя первый элемент
# на kтое место при помощи двух зеркальных отражений
# Вариант 3: более общий случай

def test_move():
    # (1)
    x1 = [5, 4, 3, 2, 1]
    move(x1, 0, 3, len(x1))
    assert x1 == [2, 1, 5, 4, 3]


def move(x: list, p: int, q: int, r: int):
    d1 = q - p
    d2 = r - q

    if d1 == d2:
        # Самый простой случай - просто меняем два отрезка местами
        for i in range(d1):
            x[p + i], x[q + i] = x[q + i], x[p + i]
    elif d1 < d2:
        # Так как левый отрезок больше, то мы из него сможем выделить подотрезок
        # длиной d1, обозначим при этом левый отрезок A1, правый B = B1 + B2, где
        # len(A1) == len(B1), переставим их
        move(x, p, q, q + d1)
        # Теперь осталось лишь переставить в B1+A1+B2 A1 с B2 местами, а у них длины уже меньше
        move(x, q, q + d1, r)
    else:
        # В этом случае правый отрезок больше, чем правый, так что обозначим
        # A = A1 + A2, B2, причем len(B2) = len(A2), поменяем A2 и B2 местами
        move(x, q - d2, q, r)
        # Теперь имеем A1 + B2 + A2, осталось поменять A1 с B2
        move(x, p, q - d2, q)
